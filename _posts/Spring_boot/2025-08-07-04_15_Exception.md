---
title: 單元 15 - Controller 層統一的 Exception 處理 - @ControllerAdvice + @ExceptionHandler
author: shawn_yu
date: 2025-08-07 04:06:00 +0800
categories: [Spring boot, Spring MVC]
tags: [Spring boot, Spring MVC]
image: /assets/img/2025-08-07-03-53-50.png
math: true
---

## @ControllerAdvice + @ExceptionHandler 註解

自定義每個 **<mark><font color="red">Exception</font></mark>** 所返回的 http response。

### @ControllerAdvice

1. 用法：只能加在 **<mark><font color="red">class</font></mark>** 上。
2. 用途：把這個 class 變成一個 bean，並且可以使用 @ExceptionHandler 註解。

### @ExceptionHandler

1. 用法：只能加在 **<mark><font color="red">方法</font></mark>** 上。
2. 用途：去catch住方法所噴出的Exception

### 例子解說

假設前端發起一個 http request，而它對應的方法會噴出一個 exception：  
Spring boot 預設會返回 http status=500 的狀態碼，表示後端處理請求時發生錯誤。

![](/assets/img/2025-08-07-04-00-07.png)

如果使用 **<mark><font color="red">@ControllerAdvice + @ExceptionHandler</font></mark>** 註解：  
他們會去接住這個 Exception，且可以自定義要返回什麼 http response 給前端。（By
@ExcetionHandler 的方法決定）

![](/assets/img/2025-08-07-04-01-18.png)

---

## 複習 Java 中 Exception 間的繼承關係

所有的 class 都繼承制
Throwable：

1. Error：系統錯誤，不需要處理。
2. Exception：程式有錯誤，需要處理。
    1. RuntimeException：程式運行期間發生的錯誤。
    2. 非 RuntimException：如 IOException，代表可能發生 IO 的錯誤。

![](/assets/img/2025-08-07-04-01-27.png)

---

## 實作 @ControllerAdvice + @ExceptionHandler

### RuntimeException

1. 新增一個 test1( ) 方法，返回一個 RuntimeException。
    ![](/assets/img/2025-08-07-04-02-03.png)
    
2. 預設返回 http status = 500 的錯誤訊息，response body 也印出預設的資訊。
    ![](/assets/img/2025-08-07-04-01-45.png)
    
3. 自定義要返回的 http response：
    1. 創建一個新的 class MyExceptionHandler，加上 **<mark><font color="red">@ControllerAdvice</font></mark>** 註解（class 會變成 bean，並可使用 @ExceptionHandler 註解）。
        ![](/assets/img/2025-08-07-04-02-26.png)
        
    2. 在 Class 中建立一個方法，並在上面加上 **<mark><font color="red">@ExceptionHandler</font></mark>** 註解，後面括號寫上 Exception 名稱（Ex：**<mark><font color="red">RuntimeException.class</font></mark>**）。  
        方法返回類型為 ResponseEntity<?>，並且有一個參數為 RuntimeException 類型，名稱隨便取。
        ![](/assets/img/2025-08-07-04-02-38.png)
        
    3. 方法返回一個 ResponseEntity object，設定希望返回的 http status 跟 response body。  
        其中 body 中的 **<mark><font color="red">exception.getMessage( )</font></mark>** 函數會去取得 test1( ) 方法返回的 RuntimeException 內容，放在 response body 中。
        ![](/assets/img/2025-08-07-04-02-46.png)
        
    
4. 運行結果：返回 http status = 503，且 response body = RuntimeException: test1 error。
    ![](/assets/img/2025-08-07-04-02-55.png)
    
5. 總結：當 Controller 中 **<mark><font color="red">任何一個方法噴出 RuntimeException</font></mark>** 時，@ExceptionHandler 就會將 RuntimeException 接住。並去執行下面的 handle( ) 方法，然後將返回值返回給前端。

### IllegalArgumentException

1. 新增一個 test2( ) 方法，返回一個 IllegalArgumentException。
    ![](/assets/img/2025-08-07-04-03-05.png)
    
2. 在 MyExceptionHandler class 中新增另一個 handle( ) 方法，返回 ResponseEntity 類型，且參數為IllegalArgumentException 類型。  
    在返回的 ResponseEntity object 中定義要返回的 http status 跟 response body 內容。
    ![](/assets/img/2025-08-07-04-03-14.png)
    
3. 運行結果：成功返回我們自定義的 http response。
    ![](/assets/img/2025-08-07-04-03-22.png)
    

### Exception 繼承關係

當程式噴出一個 Exception，Spring boot 會嘗試去找有沒有哪個 @ExceptionHandler 去處理此
Exception。

1. 如果有，Spring boot就直接使用 @ExceptionHandler 對應的方法。
2. 如果沒有，Spring boot 會去查看此 Exception 繼承的class，有沒有哪個 @ExceptionHandler 去處理 **<mark><font color="red">被繼承的 class 的 Exception</font></mark>**。

![](/assets/img/2025-08-07-04-03-29.png)

Ps. Spirng boot 會一層一層找上去，不過通常只要寫到Exception class層級即可。

<**舉例**>  
我們刪除上面寫的 IllegalArgumentException 的錯誤處理。  
當 test2( ) 噴出 IllegalArgumentException 時，會使用繼承關係去使用 RuntimeException 的處理。  
![](/assets/img/2025-08-07-04-03-37.png)

---

## 使用 @ControllerAdvice 的好處 - 統一管理 Exception

1. 如果沒使用 @ControllerAdvice 的話，我們每個方法都要特別寫 try catch，決定噴出什麼
exception 時怎麼處理。  
2. 但若使用 @ControllerAdvice，可以統一決定噴出什麼 exception 就做什麼處理。

其中 @ContollerAdvice 底層邏輯就是由 **<mark><font color="red">AOP</font></mark>** 來實現的，可以想成是專門處理大家所噴出的 exception 的切面。
![](/assets/img/2025-08-07-04-03-49.png)
---
title: 單元 16 - 攔截器 Interceptor
author: shawn_yu
date: 2025-08-07 02:55:00 +0800
categories: [Spring boot, Spring MVC]
tags: [Spring boot, Spring MVC]
image: /assets/img/2025-08-07-03-53-50.png
math: true
---

## Interceptor

當前端發起一個 http request，interceptor 會先將它攔下來，並 **<mark><font color="red">檢查此 http request 有無問題</font></mark>**。  
<br>

1. 沒問題：允許 http request 進到 Controller 裡面，執行 url 路徑對應的 test() 方法。
    ![](/assets/img/2025-08-07-03-08-24.png)

2. 有問題：不允許 http request 執行對應方法，而是 **<mark><font color="red">直接返回錯誤訊息</font></mark>**給前端。
    ![](/assets/img/2025-08-07-03-08-58.png)
    

⇒ Interceptor（攔截器）有點類似保全的概念，檢查 http request 是否有問題。

---

## 實作 Interceptor

### Code 寫法

1. 先把 MyController 中 test1() 與 test2() 方法做改寫。
    ![](/assets/img/2025-08-07-03-09-47.png)
    
2. 建立一個攔截器：新增新的 class MyInterceptor，在上面加上 **<mark><font color="red">@Component 註解</font></mark>**，並去 **<mark><font color="red">實現 HandlerInterceptor interface</font></mark>**。
    ![](/assets/img/2025-08-07-03-10-08.png)
    
3. 要在 MyInterceptor class 中寫攔截 http request 的判斷邏輯，我們先查看 HandlerInterceptor interface 的內容。
    1. **<mark><font color="red">preHandle() 方法</font></mark>**：http request 一進來時，攔截器就會執行此方法，去判斷 http request 是否有問題。
    2. postHandle(), afterCompletion() 方法：在 url 路徑對應的方法執行完畢後，攔截器才會去執行這兩個方法。
        ![](/assets/img/2025-08-07-03-10-17.png)  
        <br>

4. 在 MyController 中實作 HandlerInterceptor 的 preHandle() 方法：
    1. 左鍵 → Generate → Override method → 選擇 preHandle() 方法。
        ![](/assets/img/2025-08-07-03-10-26.png)
        
    2. preHandle() 方法會返回一個 boolean 值，true 代表允許此 http request 通過，false 代表不允許此 http request 通過，因此 **<mark><font color="red">如何設計這個方法的返回值非常重要</font></mark>**。
        ![](/assets/img/2025-08-07-03-10-34.png)
        
    3. 例如：我們可以限制 http request 的 header 內容，來決定是否允許 http request 通過等等。
    
5. 建立一個新的 class MyConfig，並在上面加上 @Configuration 註解，也就是將這個 class 成為一個設定 Spring 的 class  ⇒  我們可以在這個 class 中 **<mark><font color="red">設定要將攔截器套用到哪些 url 路徑上</font></mark>**。
    1. 將 MyConfig class 去實現 WebMvcConfigurer interface。
    2. Override addInterceptors() 方法。
    3. 加上一個 myInterceptor 變數，並加上 @Autowired 註解，注入剛剛創建的攔截器。
    4. 在 addInterceptors() 方法中寫上 **<mark><font color="red">registry.addInterceptor(myInterceptor).addPathPatterns (”/*”)</font></mark>**，將剛剛創建的攔截器套用到所有的 url 路徑上。
    ![](/assets/img/2025-08-07-03-10-44.png)  
    <br>    

> 💡 **重點：**
> 攔截器寫法中最重要的是，preHandle() 方法返回的值，如何設計這個返回值很重要。
> - 返回 true：允許 http request 通過。
> - 返回 flase：拒絕 http request。

### 運行結果

1. 若返回 true：運行成功，並在 response body 中返回 Hello test1，且在 console 中先印出了 "執行 MyInterceptor 的 preHandle 方法”（因為執行方法前會先執行 preHandle 方法）。
    ![](/assets/img/2025-08-07-03-10-55.png)
    ![](/assets/img/2025-08-07-03-11-03.png)
    
2. 若返回 false：依然運行成功，但 response body 沒有任何內容，而 console 中也只有印出  "執行 MyInterceptor 的 preHandle 方法”，代表指執行 preHandle 方法而沒有執行 test1() 方法。  
    ⇒ 因為攔截器 return false，拒絕讓 http request 通過。
    ![](/assets/img/2025-08-07-03-11-12.png)
    ![](/assets/img/2025-08-07-03-11-20.png)
    

<**補充**>  
我們也可以自行設定要返回的 http 狀態碼，例如：我們返回 http status = 401，代表 “無法通過身分驗證” （可透過此方法寫出「身分驗證」的程式 ）。
![](/assets/img/2025-08-07-03-11-29.png)
![](/assets/img/2025-08-07-03-11-36.png)